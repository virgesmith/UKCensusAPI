
#' Interactive metadata query
#'
#' This function calls an interactive script where the user selects a table, a geography, and selects fields, optionally filtering by value.
#' This script will not run in RStudio due to the way it handles standard input. Please run in a standalone R session (or call the python script directly)
#' @examples
#' \dontrun{queryMetadata()}
#' @export
queryMetadata = function() {
  # first check we are not running in RStudio (in which can we cannot run interatively, since RStudio redirects stdin from /dev/null)
  if (.Platform$GUI == "RStudio") {
    cat("This interactive code cannot be run from within RStudio due to the way RStudio handles stdin.\n")
    cat("Please either run it from a standalone R session, or call the python code (interactive.py) directly\n")
  } else {
    system("scripts/interactive.py")
  }
}

#' Geographic code lookup
#'
#' This function returns the nomisweb code for a particular geographic area type
#' @param api an instance of the API (returned by instance())
#' @param geoCodeString the string representation of a geography, e.g MSOA11
#' @return code - an integer
#' @examples
#' library(UKCensusAPI)
#' censusapi = instance("/tmp/UKCensusAPI")
#' geoCodeLookup(censusapi, "MSOA11")
#' @export
geoCodeLookup = function(api, geoCodeString) {
  return(as.integer(api$GeoCodeLookup[geoCodeString]))
}

#' getMetadata()
#' Fetch the metadata for a census table
#'
#' @param api the census provider api
#' @param tableName the name of the census table
#' @return metadata a list data structure containing the table metadata
#' @examples
#' \dontrun{
#' library(UKCensusAPI)
#' censusapi = instance("/tmp/UKCensusAPI")
#' getMetadata(censusapi, "KS001")
#' }
#' @export
getMetadata = function(api, tableName) {
  return(api$get_metadata(tableName))
}

#' getData()
#' Fetch and cache census data using a predefined query
#'
#' Ensure all query numeric parameters are passed as strings (e.g. "0" not 0)
#' This prevents conversion to floating-point which can makie queries fail
#' @param api a predefined query
#' @param tableName name of census table (e.g KS401EW)
#' @param internalName internal name of census table (e.g NM_618_1)
#' @param query query parameters
#' @return a data.frame contraing the downloaded data
#' @examples
#' \dontrun{
#' library(UKCensusAPI)
#' censusapi = instance("/tmp/UKCensusAPI")
#' table = "KS102EW"
#' meta=getMetadata(censusapi, table)
#' # queryParams can be autogenerated using the interactive query functionality
#' queryParams = list(
#'   geography = "1249902593...1249902596,1249934513...1249934514",
#'   MEASURES = "20100",
#'   select = "GEOGRAPHY_CODE,OBS_VALUE",
#'   CELL = "0",
#'   RURAL_URBAN = "0",
#'   date = "latest"
#' )
#' getData(censusapi, table, meta$nomis_table, queryParams)
#' }
#' @export
getData = function(api, tableName, internalName, query) {
  # returned value is filename (or error) to avoid data frame compatibility issues
  filename = api$get_data(tableName, internalName, query, TRUE)
  # TODO check that string isnt an error!
  return(read.csv(filename, sep="\t", stringsAsFactors = FALSE))
}

#' Map local authority names to nomisweb codes
#'
#' @param api an instance of the UKCensusData API.
#' @param laNames a string vector of local authority names or ONS codes.
#' @return an integer vector of nomisweb local authority codes
#' @examples
#' library(UKCensusAPI)
#' censusapi = instance("/tmp/UKCensusAPI")
#' codes = getLADCodes(censusapi, c("Leeds","Bradford"))
#' @export
getLADCodes = function(api, laNames) {
  return(api$get_lad_codes(laNames))
}

#' geoCodes
#' Get nomisweb geographical codes for a region
#'
#' @param api the instance of the an integer vector of nomisweb geographical codes
#' @param coverage an integer vector of nomisweb geographical codes
#' @param resolution the nomisweb code for a particular area type (e.g. 297 for MSOA)
#' @return a compressed string (nomisweb format) containing nomisweb area codes
#' @examples
#' library(UKCensusAPI)
#' censusapi = instance("/tmp/UKCensusAPI")
#' coverage = getLADCodes(censusapi, c("City of London"))
#' resolution = geoCodeLookup(censusapi, "LSOA11")
#' codes = geoCodes(censusapi, coverage, resolution)
#' @export
geoCodes = function(api, coverage, resolution) {
  # force correct types
  return(api$get_geo_codes(as.integer(coverage), as.integer(resolution)))
}

#' contextify
#'
#' Append table with a contextual column.
#'
#' @param api the instance of the an integer vector of nomisweb geographical codes
#' @param tableName name of census table
#' @param columnName name of column in the table
#' @param table the table
#' @return the table containing a new column with the contextual data
#' @examples
#' \dontrun{
#' library("UKCensusAPI")
#' cacheDir = "/tmp/UKCensusAPI/"
#' censusapi = UKCensusAPI::instance(cacheDir)
#' table = "KS401EW"
#' table_internal = "NM_618_1"
#' queryParams = list(
#'   date = "latest",
#'   CELL = "7...13", # dwelling type
#'   select = "GEOGRAPHY_CODE,CELL,OBS_VALUE",
#'   MEASURES = "20100",
#'   geography = "1245710558...1245710560",
#'   RURAL_URBAN = "0"
#' )
#' KS401EW = UKCensusAPI::getData(censusapi, table, table_internal, queryParams)
#' annotated = contextify(censusapi, table, "CELL", KS401EW)
#' }
#' @export
contextify = function(api, tableName, columnName, table) {
  metadata = api$load_metadata(tableName)
  # append a column using the value lookup provided by the metadata...
  # Look at R go! such exquisitely beautiful and intuitive syntax
  table[paste0(columnName, "_NAME")] = unlist(metadata$fields[columnName][[1]][as.character(table[[columnName]])])
  return(table)
}
